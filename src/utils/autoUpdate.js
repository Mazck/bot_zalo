// includes/autoUpdater.js
import { exec, execSync, spawn } from 'child_process';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { promises as fs, existsSync } from 'fs';
import chalk from 'chalk';
import ora from 'ora';
import fetch from 'node-fetch';
import cron from 'node-cron';
import { createInterface } from 'readline';
import dotenv from 'dotenv';
import { defaultLogger } from '../utils/logger.js';
import { createGzip } from 'zlib';
import { pipeline } from 'stream/promises';
import { createReadStream, createWriteStream } from 'fs';

dotenv.config();

class AutoUpdater {
    constructor(options = {}) {
        this.config = {
            repository: options.repository || process.env.GITHUB_REPO || 'username/repo',
            branch: options.branch || process.env.GITHUB_BRANCH || 'main',
            interval: options.interval || '*/15 * * * *', // m·ªói 15 ph√∫t m·∫∑c ƒë·ªãnh
            autoInstall: options.autoInstall !== false,
            autoPull: options.autoPull !== false,
            autoRestart: options.autoRestart !== false,
            token: options.token || process.env.GITHUB_TOKEN || null,
            verbose: options.verbose || false,
            backupDir: options.backupDir || './backups',
            adminEnabled: options.adminEnabled || process.env.ADMIN_CONSOLE === 'true',
            maxBackups: options.maxBackups || 5,
            compareMode: options.compareMode || 'files', // Thay ƒë·ªïi m·∫∑c ƒë·ªãnh sang 'files'
            notifyChanges: options.notifyChanges !== false,
            updateTimeout: options.updateTimeout || 300000, // 5 ph√∫t
            skipPaths: options.skipPaths || ['node_modules', '.git', 'backups', '.env', 'logs'],
            preUpdateCommand: options.preUpdateCommand || null,
            postUpdateCommand: options.postUpdateCommand || null,
            // Th√™m t√πy ch·ªçn m·ªõi
            updateIndividualFiles: options.updateIndividualFiles !== false,
            hotReload: options.hotReload !== false,
        };

        this.logger = options.logger || defaultLogger;
        this.bot = options.bot || null;
        this.lastCommit = null;
        this.isRunning = false;
        this.cronJob = null;
        this.adminConsole = null;
        this.__dirname = dirname(fileURLToPath(import.meta.url));
        this.commitFilePath = join(this.__dirname, '..', '.lastcommit');
        this.updateLockPath = join(this.__dirname, '..', '.updatelock');
        this.changelog = [];
        this.updateTimeout = null;
        this.webhookUrl = process.env.UPDATE_WEBHOOK_URL || null;
        this.cachedRequireModules = new Map(); // L∆∞u tr·ªØ cache c·ªßa module ƒë√£ require
    }

    async init() {
        try {
            // Ki·ªÉm tra xem Git c√≥ ƒë∆∞·ª£c c√†i ƒë·∫∑t kh√¥ng
            await this.checkGitInstallation();

            // T·∫°o th∆∞ m·ª•c backup n·∫øu ch∆∞a t·ªìn t·∫°i
            await fs.mkdir(this.config.backupDir, { recursive: true });

            // Ki·ªÉm tra lock file cho qu√° tr√¨nh c·∫≠p nh·∫≠t
            await this.checkUpdateLock();

            // ƒê·ªçc commit hash cu·ªëi c√πng ƒë√£ bi·∫øt
            await this.loadLastCommit();

            // Kh·ªüi ƒë·ªông cron job n·∫øu interval ƒë∆∞·ª£c c·∫•u h√¨nh
            if (this.config.interval) this.startUpdateChecker();

            // Kh·ªüi t·∫°o admin console n·∫øu ƒë∆∞·ª£c b·∫≠t
            if (this.config.adminEnabled) this.initAdminConsole();

            this.logger.info(chalk.green('‚úÖ Auto-updater initialized successfully'));
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to initialize auto-updater:'), error);
        }
    }

    async checkGitInstallation() {
        try {
            await this.execPromise('git --version');
        } catch (error) {
            throw new Error('Git is not installed or not in PATH. Auto-updater requires Git to be installed.');
        }
    }

    async checkUpdateLock() {
        try {
            if (existsSync(this.updateLockPath)) {
                const lockData = JSON.parse(await fs.readFile(this.updateLockPath, 'utf-8'));
                const now = Date.now();

                // N·∫øu lock qu√° h·∫°n (h∆°n 30 ph√∫t), x√≥a lock file
                if (now - lockData.timestamp > 1800000) {
                    await fs.unlink(this.updateLockPath);
                    this.logger.warn(chalk.yellow('üîì Removed stale update lock file'));
                } else {
                    this.logger.warn(chalk.yellow('‚ö†Ô∏è Update process is locked by another instance'));
                }
            }
        } catch (error) {
            // N·∫øu c√≥ l·ªói khi ƒë·ªçc lock file, x√≥a file ƒë√≥
            try {
                await fs.unlink(this.updateLockPath);
            } catch { }
        }
    }

    async createUpdateLock() {
        await fs.writeFile(
            this.updateLockPath,
            JSON.stringify({ timestamp: Date.now(), pid: process.pid })
        );
    }

    async releaseUpdateLock() {
        try {
            await fs.unlink(this.updateLockPath);
        } catch { }
    }

    startUpdateChecker() {
        if (this.cronJob) this.cronJob.stop();

        this.cronJob = cron.schedule(this.config.interval, async () => {
            this.logger.info(chalk.blue('üîç Checking for updates...'));
            await this.checkForUpdates();
        });

        this.logger.info(chalk.blue(`üïí Update checker scheduled (${this.config.interval})`));
    }

    async loadLastCommit() {
        try {
            this.lastCommit = await fs.readFile(this.commitFilePath, 'utf-8');
            this.lastCommit = this.lastCommit.trim();

            if (this.config.verbose) {
                this.logger.info(chalk.blue(`üìù Last recorded commit: ${this.lastCommit.substring(0, 7)}`));
            }
        } catch {
            const currentCommit = await this.getCurrentCommit();
            await this.saveLastCommit(currentCommit);
            this.lastCommit = currentCommit;

            this.logger.info(chalk.blue(`üìù Initialized with current commit: ${currentCommit.substring(0, 7)}`));
        }
    }

    async saveLastCommit(commitHash) {
        try {
            await fs.writeFile(this.commitFilePath, commitHash);
            this.lastCommit = commitHash;
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to save last commit:'), error);
        }
    }

    async getCurrentCommit() {
        try {
            const result = await this.execPromise('git rev-parse HEAD');
            return result.stdout.trim();
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to get current commit:'), error);
            return 'unknown';
        }
    }

    async checkForUpdates(force = false) {
        // Ki·ªÉm tra n·∫øu ƒëang c√≥ qu√° tr√¨nh c·∫≠p nh·∫≠t ch·∫°y
        if (this.isRunning) {
            this.logger.warn(chalk.yellow('‚ö†Ô∏è Update process already running'));
            return;
        }

        // Ki·ªÉm tra lock file
        if (existsSync(this.updateLockPath) && !force) {
            this.logger.warn(chalk.yellow('‚ö†Ô∏è Update process is locked. Use force option to override.'));
            return;
        }

        this.isRunning = true;
        await this.createUpdateLock();

        // ƒê·∫∑t timeout ƒë·ªÉ tr√°nh c·∫≠p nh·∫≠t b·ªã treo
        this.updateTimeout = setTimeout(() => {
            this.logger.error(chalk.red('‚ùå Update process timed out'));
            this.isRunning = false;
            this.releaseUpdateLock();
        }, this.config.updateTimeout);

        const spinner = ora('Checking for updates...').start();

        try {
            // Ki·ªÉm tra commit m·ªõi nh·∫•t t·ª´ GitHub
            const latestCommit = await this.getLatestCommit();
            if (!latestCommit) {
                spinner.fail('Failed to fetch latest commit');
                return;
            }

            // Fetch changes t·ª´ remote
            await this.execPromise('git fetch origin');

            // L·∫•y danh s√°ch c√°c file ƒë√£ thay ƒë·ªïi
            const changedFiles = await this.getChangedFiles();

            if (changedFiles.length === 0) {
                spinner.succeed('Already up to date. No files changed.');
                clearTimeout(this.updateTimeout);
                this.isRunning = false;
                await this.releaseUpdateLock();
                return;
            }

            spinner.text = `Update found! ${changedFiles.length} file(s) changed.`;

            // L∆∞u changelog
            this.changelog = await this.getChangelog(this.lastCommit, latestCommit);

            // T·∫°o backup tr∆∞·ªõc khi c·∫≠p nh·∫≠t
            await this.createBackup();

            // Ch·∫°y l·ªánh pre-update n·∫øu ƒë∆∞·ª£c c·∫•u h√¨nh
            if (this.config.preUpdateCommand) {
                spinner.text = 'Running pre-update command...';
                await this.execPromise(this.config.preUpdateCommand);
            }

            if (this.config.updateIndividualFiles) {
                // C·∫≠p nh·∫≠t t·ª´ng file ri√™ng l·∫ª
                spinner.text = 'Updating individual files...';
                await this.updateIndividualFiles(changedFiles);

                // ƒê√°nh d·∫•u l√† ƒë√£ c·∫≠p nh·∫≠t ƒë·∫øn commit m·ªõi nh·∫•t
                await this.saveLastCommit(latestCommit);
            } else {
                // Pull to√†n b·ªô thay ƒë·ªïi
                if (this.config.autoPull) {
                    spinner.text = 'Pulling latest changes...';
                    await this.pullChanges();
                }
            }

            if (this.config.autoInstall) {
                spinner.text = 'Installing dependencies...';
                await this.installDependencies();
            }

            // Ch·∫°y l·ªánh post-update n·∫øu ƒë∆∞·ª£c c·∫•u h√¨nh
            if (this.config.postUpdateCommand) {
                spinner.text = 'Running post-update command...';
                await this.execPromise(this.config.postUpdateCommand);
            }

            // Hot reload c√°c module ƒë√£ thay ƒë·ªïi
            if (this.config.hotReload) {
                spinner.text = 'Hot reloading updated modules...';
                await this.hotReloadModules(changedFiles);
            }

            spinner.succeed(chalk.green(`‚úÖ Update successful! Updated ${changedFiles.length} files to commit: ${latestCommit.substring(0, 7)}`));

            // D·ªçn d·∫πp c√°c b·∫£n backup c≈©
            await this.cleanupOldBackups();

            // G·ª≠i th√¥ng b√°o v·ªÅ c√°c thay ƒë·ªïi n·∫øu ƒë∆∞·ª£c b·∫≠t
            if (this.config.notifyChanges) {
                await this.notifyChanges(latestCommit, changedFiles);
            }

            // Kh√¥ng kh·ªüi ƒë·ªông l·∫°i bot - Theo y√™u c·∫ßu
        } catch (error) {
            spinner.fail('Update failed');
            this.logger.error(chalk.red('Update error:'), error);

            // Th·ª≠ kh√¥i ph·ª•c t·ª´ backup n·∫øu c√≥ l·ªói
            await this.recoverFromBackup();
        } finally {
            clearTimeout(this.updateTimeout);
            this.isRunning = false;
            await this.releaseUpdateLock();
        }
    }

    async getLatestCommit() {
        try {
            const [owner, repo] = this.config.repository.split('/');
            const url = `https://api.github.com/repos/${owner}/${repo}/commits/${this.config.branch}`;
            const headers = { 'User-Agent': 'ZaloBot-AutoUpdater' };

            if (this.config.token) {
                headers['Authorization'] = `token ${this.config.token}`;
            }

            const response = await fetch(url, { headers });

            if (!response.ok) {
                throw new Error(`GitHub API error: ${response.statusText} (${response.status})`);
            }

            const data = await response.json();
            return data.sha;
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to get latest commit:'), error);
            return null;
        }
    }

    async getChangedFiles() {
        try {
            const result = await this.execPromise(`git diff --name-only HEAD origin/${this.config.branch}`);

            if (!result.stdout.trim()) return [];

            const changedFiles = result.stdout
                .trim()
                .split('\n')
                .filter(file => !this.config.skipPaths.some(path => file.startsWith(path)));

            return changedFiles;
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to get changed files:'), error);
            return [];
        }
    }

    // Ph∆∞∆°ng th·ª©c m·ªõi ƒë·ªÉ c·∫≠p nh·∫≠t t·ª´ng file ri√™ng l·∫ª
    async updateIndividualFiles(changedFiles) {
        if (!changedFiles.length) return;

        try {
            for (const file of changedFiles) {
                this.logger.info(chalk.blue(`üìÑ Updating file: ${file}`));

                // T·∫°o backup cho file hi·ªán t·∫°i
                if (existsSync(join(this.__dirname, '..', file))) {
                    await fs.copyFile(
                        join(this.__dirname, '..', file),
                        join(this.__dirname, '..', `${file}.bak`)
                    );
                }

                try {
                    // L·∫•y n·ªôi dung t·ª´ remote v√† ghi ƒë√® file
                    const result = await this.execPromise(`git show origin/${this.config.branch}:${file}`);

                    // ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
                    const dir = dirname(join(this.__dirname, '..', file));
                    await fs.mkdir(dir, { recursive: true });

                    // Ghi n·ªôi dung m·ªõi v√†o file
                    await fs.writeFile(join(this.__dirname, '..', file), result.stdout);

                    // X√≥a backup n·∫øu th√†nh c√¥ng
                    if (existsSync(join(this.__dirname, '..', `${file}.bak`))) {
                        await fs.unlink(join(this.__dirname, '..', `${file}.bak`));
                    }
                } catch (error) {
                    this.logger.error(chalk.red(`‚ùå Failed to update file ${file}:`), error);

                    // Kh√¥i ph·ª•c t·ª´ backup n·∫øu c√≥ l·ªói
                    if (existsSync(join(this.__dirname, '..', `${file}.bak`))) {
                        await fs.copyFile(
                            join(this.__dirname, '..', `${file}.bak`),
                            join(this.__dirname, '..', file)
                        );
                        await fs.unlink(join(this.__dirname, '..', `${file}.bak`));
                        this.logger.info(chalk.yellow(`‚ö†Ô∏è Restored backup for file: ${file}`));
                    }
                }
            }
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to update individual files:'), error);
            throw error;
        }
    }

    // Ph∆∞∆°ng th·ª©c m·ªõi ƒë·ªÉ hot reload c√°c module ƒë√£ thay ƒë·ªïi
    async hotReloadModules(changedFiles) {
        if (!changedFiles.length) return;

        try {
            const jsFiles = changedFiles.filter(file =>
                file.endsWith('.js') ||
                file.endsWith('.mjs') ||
                file.endsWith('.cjs')
            );

            if (!jsFiles.length) {
                this.logger.info(chalk.blue('No JavaScript modules to reload'));
                return;
            }

            this.logger.info(chalk.blue(`üîÑ Hot reloading ${jsFiles.length} module(s)`));

            for (const file of jsFiles) {
                try {
                    const modulePath = join(this.__dirname, '..', file);
                    const relativeModulePath = join('..', file);

                    // X√≥a cache module
                    if (require.cache[require.resolve(modulePath)]) {
                        delete require.cache[require.resolve(modulePath)];
                        this.logger.info(chalk.blue(`üîÑ Reloaded module: ${file}`));
                    }

                    // X√≥a cache cho ES modules
                    try {
                        const moduleUrl = new URL(relativeModulePath, import.meta.url).href;
                        // Trong ES modules, kh√¥ng c√≥ cache ch√≠nh th·ª©c, nh∆∞ng ch√∫ng ta v·∫´n th√¥ng b√°o
                        this.logger.info(chalk.blue(`üîÑ Reloaded ES module: ${file}`));
                    } catch (e) {
                        // B·ªè qua l·ªói khi kh√¥ng ph·∫£i ES module
                    }
                } catch (error) {
                    this.logger.warn(chalk.yellow(`‚ö†Ô∏è Could not reload module ${file}:`), error);
                }
            }

            this.logger.info(chalk.green('‚úÖ Hot reload completed'));
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to hot reload modules:'), error);
        }
    }

    async getChangelog(oldCommit, newCommit) {
        try {
            const result = await this.execPromise(`git log --pretty=format:"%h - %s (%an)" ${oldCommit}..${newCommit}`);
            if (!result.stdout.trim()) return [];
            return result.stdout.trim().split('\n');
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to get changelog:'), error);
            return [];
        }
    }

    async createBackup() {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupName = `backup-${timestamp}`;
        const backupPath = join(this.config.backupDir, backupName);

        try {
            // T·∫°o th∆∞ m·ª•c backup
            await fs.mkdir(backupPath, { recursive: true });

            // T·∫°o file zip v·ªõi Git archive
            const archiveFile = join(this.config.backupDir, `${backupName}.tar.gz`);

            // S·ª≠ d·ª•ng Git archive ƒë·ªÉ t·∫°o tarball c·ªßa repo
            const tar = spawn('git', ['archive', '--format=tar', 'HEAD']);
            const gzip = createGzip();
            const output = createWriteStream(archiveFile);

            tar.stdout.pipe(gzip).pipe(output);

            // ƒê·ª£i qu√° tr√¨nh n√©n ho√†n t·∫•t
            await new Promise((resolve, reject) => {
                output.on('finish', resolve);
                output.on('error', reject);
                tar.on('error', reject);
            });

            // L∆∞u th√¥ng tin m√¥i tr∆∞·ªùng
            await fs.writeFile(
                join(backupPath, 'backup-info.json'),
                JSON.stringify({
                    timestamp: new Date().toISOString(),
                    commit: this.lastCommit,
                    branch: this.config.branch,
                    environment: process.env.NODE_ENV || 'development'
                }, null, 2)
            );

            // Sao ch√©p .env n·∫øu t·ªìn t·∫°i
            if (existsSync(join(this.__dirname, '..', '.env'))) {
                await fs.copyFile(
                    join(this.__dirname, '..', '.env'),
                    join(backupPath, '.env.backup')
                );
            }

            this.logger.info(chalk.blue(`üì¶ Backup created: ${backupName}.tar.gz`));
            return backupName;
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to create backup:'), error);
            throw error;
        }
    }

    async cleanupOldBackups() {
        try {
            const files = await fs.readdir(this.config.backupDir);
            const backupFiles = files
                .filter(file => file.startsWith('backup-') && file.endsWith('.tar.gz'))
                .map(file => ({
                    name: file,
                    path: join(this.config.backupDir, file),
                    time: (file.match(/backup-(\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2})/) || [])[1]
                }))
                .sort((a, b) => b.time.localeCompare(a.time));

            if (backupFiles.length > this.config.maxBackups) {
                const filesToDelete = backupFiles.slice(this.config.maxBackups);
                for (const file of filesToDelete) {
                    await fs.unlink(file.path);

                    // X√≥a th∆∞ m·ª•c backup t∆∞∆°ng ·ª©ng n·∫øu t·ªìn t·∫°i
                    const dirName = file.name.replace('.tar.gz', '');
                    const dirPath = join(this.config.backupDir, dirName);

                    if (existsSync(dirPath)) {
                        await fs.rm(dirPath, { recursive: true, force: true });
                    }

                    this.logger.info(chalk.blue(`üóëÔ∏è Deleted old backup: ${file.name}`));
                }
            }
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to cleanup old backups:'), error);
        }
    }

    async recoverFromBackup() {
        try {
            const files = await fs.readdir(this.config.backupDir);
            const backupFiles = files
                .filter(file => file.startsWith('backup-') && file.endsWith('.tar.gz'))
                .map(file => ({
                    name: file,
                    path: join(this.config.backupDir, file),
                    time: (file.match(/backup-(\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2})/) || [])[1]
                }))
                .sort((a, b) => b.time.localeCompare(a.time));

            if (backupFiles.length === 0) {
                this.logger.error(chalk.red('‚ùå No backups found for recovery'));
                return false;
            }

            const latestBackup = backupFiles[0];
            this.logger.info(chalk.yellow(`‚ö†Ô∏è Attempting recovery from ${latestBackup.name}`));

            // Kh√¥i ph·ª•c t·ª´ tarball
            await this.execPromise(`tar -xzf ${latestBackup.path} -C ${join(this.__dirname, '..')}`);

            // Kh√¥i ph·ª•c .env n·∫øu c√≥
            const envBackupPath = join(this.config.backupDir, latestBackup.name.replace('.tar.gz', ''), '.env.backup');
            if (existsSync(envBackupPath)) {
                await fs.copyFile(envBackupPath, join(this.__dirname, '..', '.env'));
            }

            this.logger.info(chalk.green('‚úÖ Recovery successful'));
            return true;
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Recovery failed:'), error);
            return false;
        }
    }

    async pullChanges() {
        try {
            // L∆∞u c√°c thay ƒë·ªïi c·ª•c b·ªô v√†o stash
            await this.execPromise('git stash');

            // K√©o c√°c thay ƒë·ªïi t·ª´ remote
            const result = await this.execPromise(`git pull origin ${this.config.branch}`);

            // √Åp d·ª•ng l·∫°i stash n·∫øu c·∫ßn
            try {
                await this.execPromise('git stash pop');
            } catch (e) {
                // B·ªè qua l·ªói n·∫øu kh√¥ng c√≥ g√¨ trong stash
            }

            this.logger.info(chalk.blue('üì• Pulled latest changes'));
            return result;
        } catch (error) {
            this.logger.error(chalk.red('‚ùå Failed to pull changes:'), error);
            throw error;
        }
    }

    async installDependencies() {
        try {
            const timeStart = Date.now();
            await this.execPromise('npm ci --no-audit --no-fund');
            const timeEnd = Date.now();

            this.logger.info(chalk.blue(`üì¶ Installed dependencies (${((timeEnd - timeStart) / 1000).toFixed(1)}s)`));
        } catch (error) {
            this.logger.warn(chalk.yellow('‚ö†Ô∏è Failed to run npm ci, falling back to npm install'));

            try {
                await this.execPromise('npm install --no-audit --no-fund');
                this.logger.info(chalk.blue('üì¶ Installed dependencies'));
            } catch (fallbackError) {
                this.logger.error(chalk.red('‚ùå Failed to install dependencies:'), fallbackError);
                throw fallbackError;
            }
        }
    }

    async notifyChanges(newCommit, changedFiles = []) {
        if (!this.changelog.length) return;

        // Log th√¥ng b√°o
        this.logger.info(chalk.green('üìã Changelog:'));
        for (const change of this.changelog) {
            this.logger.info(chalk.gray(`  ${change}`));
        }

        // Log c√°c file ƒë√£ thay ƒë·ªïi
        if (changedFiles.length) {
            this.logger.info(chalk.green('üìÇ Changed files:'));
            for (const file of changedFiles) {
                this.logger.info(chalk.gray(`  ${file}`));
            }
        }

        // G·ª≠i webhook n·∫øu ƒë∆∞·ª£c c·∫•u h√¨nh
        if (this.webhookUrl) {
            try {
                const filesDescription = changedFiles.length > 0
                    ? `\n\n**Changed files:**\n${changedFiles.map(f => `- \`${f}\``).join('\n')}`
                    : '';

                const payload = {
                    content: `**Bot updated to ${newCommit.substring(0, 7)}**`,
                    embeds: [{
                        title: 'Update Changelog',
                        description: this.changelog.join('\n') + filesDescription,
                        color: 3066993,
                        footer: {
                            text: `Updated at ${new Date().toISOString()}`
                        }
                    }]
                };

                await fetch(this.webhookUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
            } catch (error) {
                this.logger.error(chalk.red('‚ùå Failed to send webhook notification:'), error);
            }
        }
    }

    async restartBot() {
        this.logger.info(chalk.blue('üîÑ Restarting bot...'));

        if (this.bot && typeof this.bot.shutdown === 'function') {
            try {
                await this.bot.shutdown();
            } catch (error) {
                this.logger.error(chalk.red('‚ùå Error during bot shutdown:'), error);
            }
        }

        setTimeout(() => {
            process.on('exit', () => {
                execSync(`node ${process.argv[1]}`, { stdio: 'inherit' });
            });
            process.exit(0);
        }, 1000);
    }

    async reset(newConfig = null) {
        this.logger.info(chalk.blue('üîÑ Resetting auto-updater...'));

        // Stop existing processes
        if (this.cronJob) {
            this.cronJob.stop();
            this.cronJob = null;
        }

        // Clear any running update process
        if (this.isRunning) {
            clearTimeout(this.updateTimeout);
            this.isRunning = false;
            await this.releaseUpdateLock();
        }

        // Update config if provided
        if (newConfig) {
            this.config = { ...this.config, ...newConfig };
        }

        // Reset state
        this.changelog = [];

        // Re-initialize core components
        await this.loadLastCommit();

        // Restart update checker
        if (this.config.interval) {
            this.startUpdateChecker();
        }

        this.logger.info(chalk.green('‚úÖ Auto-updater reset successfully'));
        return true;
    }

    initAdminConsole() {
        this.adminConsole = createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: chalk.cyan('Admin > ')
        });

        this.adminConsole.on('line', async (line) => {
            const input = line.trim();
            if (!input) return this.adminConsole.prompt();

            try {
                await this.handleAdminCommand(input);
            } catch (error) {
                this.logger.error(chalk.red('‚ùå Command error:'), error);
            }
            this.adminConsole.prompt();
        });

        console.log(chalk.green('üîß Admin Console Ready - Type "help" for commands'));
        this.adminConsole.prompt();
    }

    async handleAdminCommand(input) {
        const [command, ...args] = input.split(' ');

        switch (command.toLowerCase()) {
            case 'help':
                console.log(chalk.cyan('Available commands:'));
                console.log(chalk.gray('  help           - Show this help'));
                console.log(chalk.gray('  update         - Check for updates and apply if available'));
                console.log(chalk.gray('  force-update   - Force update regardless of current state'));
                console.log(chalk.gray('  restart        - Restart the bot'));
                console.log(chalk.gray('  status         - Show current update status'));
                console.log(chalk.gray('  backup         - Create a manual backup'));
                console.log(chalk.gray('  recover        - Recover from the latest backup'));
                console.log(chalk.gray('  config         - Show current configuration'));
                console.log(chalk.gray('  exit           - Exit the application'));
                break; console.log(chalk.gray('  exit           - Exit the application'));
                break;

            case 'update':
                console.log(chalk.blue('üîç Checking for updates...'));
                await this.checkForUpdates();
                break;

            case 'force-update':
                console.log(chalk.blue('üîÑ Forcing update...'));
                await this.checkForUpdates(true);
                break;

            case 'restart':
                console.log(chalk.blue('üîÑ Restarting...'));
                await this.restartBot();
                break;

            case 'status':
                console.log(chalk.cyan('üìä Status:'));
                console.log(chalk.gray(`  Running: ${this.isRunning}`));
                console.log(chalk.gray(`  Last commit: ${this.lastCommit?.substring(0, 7) || 'unknown'}`));
                console.log(chalk.gray(`  Update schedule: ${this.config.interval}`));

                try {
                    const latestCommit = await this.getLatestCommit();
                    console.log(chalk.gray(`  Latest commit: ${latestCommit?.substring(0, 7) || 'unknown'}`));

                    const needsUpdate = latestCommit && latestCommit !== this.lastCommit;
                    console.log(chalk.gray(`  Needs update: ${needsUpdate ? chalk.yellow('Yes') : chalk.green('No')}`));

                    if (needsUpdate) {
                        const changedFiles = await this.getChangedFiles();
                        console.log(chalk.gray(`  Changed files: ${changedFiles.length}`));
                    }
                } catch (error) {
                    console.log(chalk.red(`  Error checking status: ${error.message}`));
                }
                break;

            case 'backup':
                console.log(chalk.blue('üì¶ Creating backup...'));
                const backupName = await this.createBackup();
                console.log(chalk.green(`‚úÖ Backup created: ${backupName}`));
                break;

            case 'recover':
                console.log(chalk.yellow('‚ö†Ô∏è Recovering from latest backup...'));
                const success = await this.recoverFromBackup();
                if (success) {
                    console.log(chalk.green('‚úÖ Recovery successful'));
                } else {
                    console.log(chalk.red('‚ùå Recovery failed'));
                }
                break;

            case 'config':
                console.log(chalk.cyan('‚öôÔ∏è Configuration:'));
                Object.entries(this.config).forEach(([key, value]) => {
                    console.log(chalk.gray(`  ${key}: ${typeof value === 'object' ? JSON.stringify(value) : value}`));
                });
                break;

            case 'exit':
                console.log(chalk.blue('üëã Exiting...'));
                process.exit(0);
                break;

            default:
                console.log(chalk.red(`‚ùå Unknown command: ${command}`));
                console.log(chalk.gray('Type "help" for available commands'));
        }
    }

    execPromise(command) {
        return new Promise((resolve, reject) => {
            exec(command, { cwd: join(this.__dirname, '..') }, (error, stdout, stderr) => {
                if (error) {
                    return reject(error);
                }
                resolve({ stdout, stderr });
            });
        });
    }
}

export default AutoUpdater;